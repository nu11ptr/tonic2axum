use std::collections::HashMap;
use std::error::Error;
use std::path::{Path, PathBuf};

use flexstr::LocalStr;
use flexstr::str::LocalStrRef;
use prost_build::ServiceGenerator;
use prost_reflect::prost_types::FileDescriptorSet;

use crate::{ProstConfig, TonicBuilder, codegen::Generator};

const DEFAULT_FDS_FILE_NAME: &str = "fds.bin";

/// The state type for a given service.
pub enum StateType {
    Custom(Box<syn::Type>),
    Generic,
}

pub(crate) struct GeneratorConfig {
    pub state_types: HashMap<LocalStr, StateType>,
    pub skip_bidi_streaming: bool,
    pub generate_openapi: bool,
    pub value_suffix: &'static str,
    pub type_suffix: &'static str,
    pub body_message_suffix: &'static str,
    pub query_message_suffix: &'static str,
}

impl Default for GeneratorConfig {
    fn default() -> Self {
        Self {
            state_types: HashMap::new(),
            skip_bidi_streaming: true,
            generate_openapi: true,
            value_suffix: "__",
            type_suffix: "__",
            body_message_suffix: "Body",
            query_message_suffix: "Query",
        }
    }
}

/// The builder for the tonic2axum code generator.
pub struct Builder {
    fds_path: Option<PathBuf>,
    prost_config: Option<ProstConfig>,
    tonic_builder: Option<TonicBuilder>,
    config: GeneratorConfig,
}

impl Builder {
    /// Create a new builder with default values.
    pub fn new() -> Self {
        Self {
            fds_path: None,
            prost_config: None,
            tonic_builder: None,
            config: GeneratorConfig::default(),
        }
    }

    /// Set whether to ignore bidirectional streaming methods (default: true).
    pub fn skip_bidi_streaming(mut self, ignore: bool) -> Self {
        self.config.skip_bidi_streaming = ignore;
        self
    }

    /// Set whether to generate an OpenAPI specification (default: true).
    pub fn generate_openapi(mut self, enable: bool) -> Self {
        self.config.generate_openapi = enable;
        self
    }

    /// Set the path to the file descriptor set.
    pub fn file_descriptor_set_path(mut self, path: impl Into<PathBuf>) -> Self {
        self.fds_path = Some(path.into());
        self
    }

    /// Set a custom state type for a given service.
    pub fn custom_state_type(
        mut self,
        service_name: impl AsRef<str>,
        state_type: impl AsRef<str>,
    ) -> Result<Self, Box<dyn Error>> {
        let name: LocalStrRef = service_name.as_ref().into();
        let type_: syn::Type = syn::parse_str(state_type.as_ref())?;
        self.config
            .state_types
            .insert(name.into_owned(), StateType::Custom(Box::new(type_)));
        Ok(self)
    }

    /// Set the state type to be any type that implements the service trait.
    pub fn generic_state_type(mut self, service_name: impl AsRef<str>) -> Self {
        let name: LocalStrRef = service_name.as_ref().into();
        self.config
            .state_types
            .insert(name.into_owned(), StateType::Generic);
        self
    }

    /// Set the prost config to customize the prost build process.
    ///
    /// > NOTE: The file descriptor set path and service generator will be overridden
    /// > by the values specified to or generated by this builder.
    pub fn prost_config(mut self, config: ProstConfig) -> Self {
        self.prost_config = Some(config);
        self
    }

    /// Set the tonic builder to customize the tonic build process.
    ///
    /// > NOTE: None of prost specific config settings will be applied.
    /// > Instead, use the [ProstConfig] directly for those settings.
    pub fn tonic_builder(mut self, builder: TonicBuilder) -> Self {
        self.tonic_builder = Some(builder);
        self
    }

    /// Compile the proto files and return the file descriptor set and its raw bytes.
    pub fn compile_protos(
        &mut self,
        protos: &[impl AsRef<Path>],
        includes: &[impl AsRef<Path>],
    ) -> Result<(FileDescriptorSet, Vec<u8>), Box<dyn Error>> {
        if self.fds_path.is_none() {
            let mut fds_path = match std::env::var("OUT_DIR") {
                Ok(out_dir) => PathBuf::from(out_dir),
                Err(_) => PathBuf::from("."),
            };
            fds_path.push(DEFAULT_FDS_FILE_NAME);
            self.fds_path = Some(fds_path);
        }

        if self.prost_config.is_none() {
            self.prost_config = Some(ProstConfig::new());
        }

        let fds_path = self.fds_path.as_ref().unwrap();
        let prost_config = self.prost_config.as_mut().unwrap();

        prost_config.file_descriptor_set_path(fds_path);
        let fds = prost_config.load_fds(protos, includes)?;
        let bytes = std::fs::read(fds_path)?;
        Ok((fds, bytes))
    }

    /// Compile the file descriptor set.
    pub fn compile_fds(
        mut self,
        fds: FileDescriptorSet,
        fds_bytes: Vec<u8>,
    ) -> Result<(), Box<dyn Error>> {
        let mut prost_config = match self.prost_config.take() {
            Some(config) => config,
            None => ProstConfig::new(),
        };

        if self.config.generate_openapi {
            prost_config.type_attribute(".", "#[derive(utoipa::ToSchema)]");
        }

        let service_generator = self.make_service_generator(fds_bytes)?;
        prost_config.service_generator(service_generator);
        prost_config.compile_fds(fds)?;
        Ok(())
    }

    /// Compile the proto files and file descriptor set.
    pub fn compile(
        mut self,
        protos: &[impl AsRef<Path>],
        includes: &[impl AsRef<Path>],
    ) -> Result<(), Box<dyn Error>> {
        let (fds, fds_bytes) = self.compile_protos(protos, includes)?;
        self.compile_fds(fds, fds_bytes)
    }

    fn make_service_generator(
        self,
        fds_bytes: Vec<u8>,
    ) -> Result<Box<dyn ServiceGenerator>, Box<dyn Error>> {
        let tonic_builder = match self.tonic_builder {
            Some(builder) => builder,
            None => tonic_prost_build::configure(),
        };
        Ok(Box::new(Generator::new(
            tonic_builder.service_generator(),
            fds_bytes,
            self.config,
        )?))
    }
}

impl Default for Builder {
    fn default() -> Self {
        Self::new()
    }
}
